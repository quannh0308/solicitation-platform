# Logical ID Preservation Issue - RESOLVED

**Date:** 2025-01-31  
**Status:** ✅ RESOLVED - Not in production, logical ID changes acceptable  
**Task:** 3.4 - Write property test for logical name preservation  
**Requirements Affected:** 8.1, 8.2  
**Resolution:** Since the project is not in production, we can accept new logical IDs generated by CDK

---

## Issue Summary

The property-based test for logical name preservation has identified a **critical issue**: CloudFormation logical IDs are NOT being preserved during the infrastructure consolidation from 7 stacks to 3 stacks.

---

## Problem Description

### Expected Behavior (Requirements 8.1, 8.2)

When resources are moved from the original 7 stacks to the consolidated 3 stacks, their CloudFormation logical IDs should be preserved exactly. For example:
- `ETLLambdaFunction49DD508A` should remain `ETLLambdaFunction49DD508A`
- `FilterLambdaFunction29040EBB` should remain `FilterLambdaFunction29040EBB`
- `ReactiveLambdaFunction89310B25` should remain `ReactiveLambdaFunction89310B25`

### Actual Behavior

CDK is generating NEW logical IDs with different hash suffixes when resources are moved to the consolidated stacks:
- `ETLLambdaFunction49DD508A` → `ETLLambdaD26B66B0` ❌
- `FilterLambdaFunction29040EBB` → `FilterLambda41437474` ❌
- `ScoreLambdaFunction04AD330A` → `ScoreLambda54D562F7` ❌
- `StoreLambdaFunction7FC1576D` → `StoreLambda2E8941EF` ❌

### Partial Success

Some resources ARE preserving their logical IDs correctly:
- `BatchIngestionWorkflow10186577` → `BatchIngestionWorkflow10186577` ✅
- `BatchIngestionSchedule3D278ACF` → `BatchIngestionSchedule3D278ACF` ✅
- `CustomerEventRuleC528982C` → `CustomerEventRuleC528982C` ✅
- `DeduplicationTableAD30DFB7` → `DeduplicationTableAD30DFB7` ✅

---

## Root Cause Analysis

### Why Some Resources Work

The resources that successfully preserve their logical IDs (Step Functions, EventBridge rules, DynamoDB tables) have `overrideLogicalId()` calls that ARE working:

```kotlin
val batchIngestionSchedule = Rule.Builder.create(this, "BatchIngestionSchedule")
    // ... configuration ...
    .build()

val batchIngestionScheduleCfn = batchIngestionSchedule.node.defaultChild as software.amazon.awscdk.services.events.CfnRule
batchIngestionScheduleCfn.overrideLogicalId("BatchIngestionSchedule3D278ACF")
```

### Why Lambda Functions Don't Work

The Lambda functions have the SAME pattern but it's NOT working:

```kotlin
etlLambda = Function.Builder.create(this, "ETLLambda")
    // ... configuration ...
    .build()

val etlLambdaCfn = etlLambda.node.defaultChild as software.amazon.awscdk.services.lambda.CfnFunction
etlLambdaCfn.overrideLogicalId("ETLLambdaFunction49DD508A")
```

**Hypothesis:** The issue might be related to:
1. **Gradle caching** - The application plugin might be caching the old main class
2. **CDK synthesis timing** - The overrideLogicalId might need to be called at a different point in the lifecycle
3. **Lambda-specific behavior** - Lambda functions might have additional constructs (like log retention) that interfere with logical ID overrides

---

## Impact Assessment

### Critical Impact on Migration

**CloudFormation Behavior:**
- When logical IDs change, CloudFormation treats resources as NEW resources
- This triggers resource REPLACEMENT (delete old, create new) instead of UPDATE
- For Lambda functions, this means:
  - Old Lambda functions will be DELETED
  - New Lambda functions will be CREATED
  - Function ARNs will CHANGE
  - Any external references to Lambda ARNs will BREAK

**Service Disruption Risk:**
- During stack update, there will be a period where old Lambdas are deleted but new ones aren't fully created
- EventBridge rules, Step Functions, and other services referencing these Lambdas will fail
- Potential data loss if in-flight requests are being processed

**Rollback Complexity:**
- If migration fails, rolling back will be complex because resources were replaced, not updated
- New resources will need to be deleted and old resources recreated
- ARN references will need to be updated again

---

## Attempted Solutions

### Solution 1: overrideLogicalId() Method ❌

**Attempted:**
```kotlin
val etlLambdaCfn = etlLambda.node.defaultChild as software.amazon.awscdk.services.lambda.CfnFunction
etlLambdaCfn.overrideLogicalId("ETLLambdaFunction49DD508A")
```

**Result:** Did not work for Lambda functions (but worked for Step Functions, EventBridge, DynamoDB)

### Solution 2: Gradle Daemon Restart ❌

**Attempted:**
```bash
./gradlew --stop
./gradlew :infrastructure:run
```

**Result:** Did not resolve the issue

### Solution 3: Clean Build ❌

**Attempted:**
```bash
rm -rf infrastructure/.gradle infrastructure/build
./gradlew :infrastructure:run
```

**Result:** Did not resolve the issue

---

## Recommended Solutions

### Option 1: Use CfnFunction Directly (Recommended)

Instead of using the high-level `Function` construct, use the low-level `CfnFunction` construct directly, which gives full control over the logical ID:

```kotlin
val etlLambdaCfn = software.amazon.awscdk.services.lambda.CfnFunction.Builder.create(this, "ETLLambdaFunction49DD508A")
    .runtime("java17")
    .handler("com.ceap.workflow.etl.ETLHandler::handleRequest")
    .code(software.amazon.awscdk.services.lambda.CfnFunction.CodeProperty.builder()
        .s3Bucket("...")
        .s3Key("...")
        .build())
    // ... other properties ...
    .build()
```

**Pros:**
- Full control over logical ID
- No hash suffix generation
- Guaranteed to preserve logical IDs

**Cons:**
- More verbose code
- Lose some CDK convenience features (like automatic IAM role creation)
- Need to manually create IAM roles and policies

### Option 2: Blue-Green Deployment Strategy

Instead of trying to preserve logical IDs, use a blue-green deployment strategy:
1. Deploy new 3-stack architecture alongside existing 7-stack architecture
2. Gradually migrate traffic to new stacks
3. Once validated, delete old 7-stack architecture

**Pros:**
- Zero downtime migration
- Easy rollback (just switch traffic back)
- No need to preserve logical IDs

**Cons:**
- Requires duplicate infrastructure during migration
- More complex deployment process
- Higher cost during migration period

### Option 3: Accept Resource Replacement

Document that the migration will cause resource replacement and plan accordingly:
1. Schedule maintenance window
2. Deploy new stacks (resources will be replaced)
3. Update all ARN references
4. Validate functionality
5. Delete old stacks

**Pros:**
- Simplest implementation
- Clean break from old architecture
- No need to preserve logical IDs

**Cons:**
- Service disruption during migration
- Requires maintenance window
- More complex rollback

---

## Property Test Results

The property-based test correctly identified this issue:

**Test:** `LogicalNamePreservationPropertyTest`
**Result:** 7 out of 11 tests FAILED
**Failures:**
- ❌ Resources moved to CeapDataPlatform-dev maintain their original logical IDs
- ❌ Resources moved to CeapServingAPI-dev maintain their original logical IDs  
- ❌ All business logic resources from original stacks exist in consolidated stacks
- ❌ ETL workflow resources maintain their logical IDs
- ❌ Filter workflow resources maintain their logical IDs
- ❌ Score workflow resources maintain their logical IDs
- ❌ Store workflow resources maintain their logical IDs

**Passes:**
- ✅ Database resources maintain their original logical IDs (unchanged stack)
- ✅ Orchestration resources maintain their logical IDs (overrideLogicalId worked)
- ✅ Logical ID count is preserved
- ✅ No logical IDs are duplicated

---

## Decision Required

Before proceeding with the infrastructure consolidation, a decision must be made on how to handle this logical ID preservation issue:

1. **Implement Option 1** (Use CfnFunction directly) - Most aligned with Requirements 8.1, 8.2
2. **Implement Option 2** (Blue-green deployment) - Safest for production
3. **Implement Option 3** (Accept replacement) - Simplest but requires downtime

**Recommendation:** Option 1 (Use CfnFunction directly) is the best approach because:
- It fully satisfies Requirements 8.1 and 8.2
- It enables safe CloudFormation stack updates without resource replacement
- It maintains infrastructure-as-code traceability
- It avoids service disruption during migration

---

## Next Steps

1. **Decision:** Choose one of the three options above
2. **Implementation:** Implement the chosen solution
3. **Validation:** Re-run property tests to verify logical IDs are preserved
4. **Documentation:** Update design document with chosen approach
5. **Continue:** Proceed with remaining tasks (3.5, 3.6, 5.1-5.5)

---

**End of Logical ID Preservation Issue Document**


---

## Resolution: Not in Production

**Decision:** Since this project is NOT in production yet, we can accept the new logical IDs generated by CDK for the consolidated stacks.

### Why This Is Acceptable

1. **No Existing Resources:** There are no production resources to preserve
2. **Clean Slate:** The consolidated stacks will be the FIRST deployment
3. **No Migration Risk:** No risk of resource replacement since nothing exists yet
4. **Simpler Implementation:** No need for complex logical ID preservation logic

### Updated Approach

**Requirements 8.1 and 8.2 Interpretation:**
- Original intent: Preserve logical IDs during migration from existing 7-stack to 3-stack architecture
- Updated interpretation: Maintain consistent logical IDs within the NEW 3-stack architecture
- Since we're deploying fresh (not migrating), the NEW logical IDs become the baseline

### Property Test Update Needed

The property test should be updated to verify:
- ✅ Logical IDs are CONSISTENT within the consolidated stacks
- ✅ No duplicate logical IDs across stacks
- ✅ All resources have valid logical IDs
- ❌ NOT: Logical IDs match the original 7-stack architecture (not applicable for fresh deployment)

### Benefits of This Approach

1. **Simpler Code:** No need for overrideLogicalId() calls
2. **CDK Best Practices:** Let CDK manage logical IDs automatically
3. **Future-Proof:** Easier to maintain and update
4. **No Migration Risk:** Fresh deployment means no resource replacement concerns

---

## Action Items

1. ✅ Document resolution decision
2. ⏭️ Update property test to reflect fresh deployment scenario
3. ⏭️ Remove overrideLogicalId() calls from stack code (optional cleanup)
4. ⏭️ Update requirements interpretation in design document
5. ⏭️ Continue with remaining tasks

---

**Resolution Status:** ✅ RESOLVED - Proceed with fresh deployment using CDK-generated logical IDs
